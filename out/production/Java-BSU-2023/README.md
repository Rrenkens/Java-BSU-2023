# Docks & Hobos
В данной задаче вам предстоит поработать с потоками и примитивами синхронизации в Java.

# Архитектура приложения
В задаче никакого шаблона предложено не будет, архитектура приложения полностью зависит только от вас (архитектура и чистота также будут оцениваться).

Все переменные должны задаваться в файле *config.json*. Путь до этого файла передается аргументов в вашу программу, при запуске она читает все переменные из этого файла и конструирует необходимые сущности.

>Всю работу ведите в пакете `by.<ваш ник>.docks_and_hobos`

# Основные действующие лица
- *Генератор кораблей* — Генератор кораблей каждые _generating_time_ секунд производит подходящий к бухте грузовой корабль.
- *Корабль* — Корабль может иметь разную грузоподъемность и один из типов груза. Диапазон грузоподъемности корабля от _ship_capacity_min_ до _ship_capacity_max_, все типы грузов перечислены в массиве _cargo_types_.
- *Тонель* — Заходя в бухту, корабли попадают в узкий тоннель, вмещающий только _max_ships_ кораблей. Корабли, которые не могут пройти, тонут. Корабли, находящиеся в тоннеле, ожидают вызова от доков.
- *Доки* — Корабли швартуются в доках для разгрузки, которая идет со скоростью _unloading_speed_ единиц товара в секунду. Разгруженные товары хранятся в доках, максимальное количество хранимого товара _dock_capacity_ для каждой единицы, если товар не помещается на склад его выкидывают.
- *Бродяги* — В доках обитает _hobos > 2_ бродяг. Они вечно голодны и имеют тягу к высокой кухне, то есть питаются исключительно “Омерзительно длинными бутербродами”. В состав порции, достаточной для временного насыщения ватаги кулинаров входит по _X_i_ единиц _i-го_ ингридента, указывается в массиве _ingridients_count_.  Бродяги воруют ингредиенты со складов в доках и готовят их над горящей бочкой: двое всегда занимаются готовкой, остальные воруют ингредиенты, при этом время, за которое один вор может украсть и принести единицу товара - _stealing_time_ секунд. Приготовив необходимую порцию еды, бродяги останавливаются на _eating_time_ секунд, чтобы поесть, после чего продолжают привычную рутину, при этом распределение ответственности за готовку и грабеж происходит случайным образом.

# Полезные ссылки
- С чего стоит начать - https://goo.gl/f1HZxk.
- Атомарные переменные — https://www.baeldung.com/java-atomic-variables
- Thread — https://www.simplilearn.com/tutorials/java-tutorial/thread-in-java
- Рассказ про многопоточность с семинара — https://disk.yandex.ru/i/rPOOINFYFwGmHQ.
- Рассказ про многопоточность в Java с семинара — https://disk.yandex.ru/i/m16sdlCFlhiJCw.

>Не испольузйте mutex и atomic там где это не требуется! Использование этих примитивов сильно замедляет выполнение программы.

# ★ Логирование
Добавьте в свое приложение библиотеку для логирования. Библиотека может быть произвольной. Логирование должно работать следующим образом:
- Логируете все что вам кажется интересным.
- Логирование должно производится и в консоль и в файл (тут может быть разный уровень логирования, чтобы не захламлять консоль).
- Каждый промежуток времени (выберите самостоятельно) файл с логами должен сохраняться и логи должны начать писаться в другой файл. Название файлов должно содержать начало записи логов в этот файл.
- Сохраните любой лог (до 100 строчек) в репозитории.

## Полезные ссылки
- Обзор на разные библиотеки логирования — https://habr.com/ru/post/247647/
- Настройка _log4j_ — https://www.codejava.net/coding/how-to-configure-log4j-as-logging-mechanism-in-java

# ★★ Condition Variable
Condition variable — является примитивом синхронизации и используется для построения более специфичных методов синхронизации таких как *Semaphore*, *Barier* и других.

Разобраться, что такое Condition Variable, как в общих чертах с помощью них построить *Semaphore* и *Barier*. Если необходимо, добавить в свой код что-то из описанного выше.

- Лекция в шаде — https://disk.yandex.ru/i/Lc9eYl-rO4Nunw
